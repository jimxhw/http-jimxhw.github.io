# 常用软件及开发工具使用说明
  ## 版本控制系统（git）
  ### 上传远程
  * gitbash操作流程及browser开发同步知识
    * git init(创建git）——git remote add origin URL（关联仓库）——git remote -v（检查当前关联的网址）——git pull origin master（将远程文件拉到本地）——git add（把文件修改添加到暂存区）——git commit（把暂存区的所有内容提交到当前分支）——git log（检查当前修改版本）——git push -u origin master（上传到远程）
    * 返回上一版本git reset --hard HEAD^ ，HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本

  * 常用git命令   
    *  直接命名 git commit -m ""
    *  查看分支：git branch
    *  创建分支：git branch <name>
    *  切换分支：git checkout <name>
    *  关联仓库 git remote add origin URL
    *  修改远程地址 git remote set-url origin URL
    *  创建+切换分支：git checkout -b <name>
    *  合并某分支到当前分支：git merge <name>
    *  删除分支：git branch -d <name>
    *  分支合并图：git log --graph
    *  普通模式合并，合并后的历史有分支:git merge --no-ff <name>
    *  合并冲突git会在本地修改文件里面给出提示，手动选择修改文件， 然后Git add ，Git cm, 再删除另外一个分支，git branch -d <name>。

  * browse同步
    * npm install -g browser-sync 安装
    * browser-sync start --server --directory -f "*.html" 安装同步html
    * browser-sync start --server --directory -f "*.html,*.js"  安装同步HTML和js
    * browser-sync start --server --directory --file "*"  安装同步当前文件夹内容
    * browser-sync start --server --directory --file "/*"  安装同步文件夹子文件夹


## 开启本地服务器（http网络服务）
  * npm install http-server -g  通过npm安装
  * http-server   使用命令

   


## 其他常用命令
  * 命令行基础
    * prompt 命令 提示符
    * 工作目录，Current Directory
      * pwd可以显示当前工作目录
    * 命令的格式
      * 命令名 参数1 参数2 参数3 参数4 ...
      * 参数是可选的
      * 
    * 一般命令，裸命令
        * pwd, cls/clear, ls,cd
        * print working diretory

    * 带选项/参数的命令
        * ls --long-output
        * ls -l
        * ls --help
        * ls -h
        * <input>
        * <input type="password" required>

    * 选项的简写与完整写法
      * command -a
      * command --append
      * command -abc <==> comamnd -a -b -c
      * 例： tar -xv    -fc ./foo.tar
    * 选项带值的命令
        * chrome.exe --proxy-pac-url "xxx"
        * chrome.exe --proxy-pac-url=https://xrlovefruits.com:5050/pac.js
        * babel a.js -o=a.compiled.js
        * babel src/a.js --output=dist/a.compiled.js
    * 将命令的输出到文件
        * echo abc > foo.txt（可输出编辑内容到文件）
    * 将命令的追加到文件
        * echo def >> foo.txt
    * pipe 前一个命令的输出(Output)做为后一个命令的输入(Input)
        * 管道符
        * IO  xxx.io  Google I/O 大会
        * input output
        * pm2 | grep "to" | lolcat    vertical bar
    * 命令行里按tab
      * 自动补全
    * ctrl+C  换行

  * 常用命令
      * ls     list （不打开以.开头的文件，使用ls -a可以显示）
      * ls -lah(显示所有文件详细内容)
      * cat,   con cate nate（查看文件内容，可一次查看多个）
      * echo （后面跟提示文字，用于脚本执行前的提示） 
      * echo 文字>a.text     将文字输入到a.text
      * cd   change directory
        * cd 相对路径（相对于当前工作目录）
          * ../表示当前文件夹的父文件夹 （中合路径中的上一个文件夹）anv/.. =0
          * ./ 表示当前文件夹，可忽略
        * cd 绝对路径，,以/开头； （cd - 上一个文件夹）
        * 补充：
          * 路径
          * 相对路径

      * sudo /super user do  超级管理员
      
      * mkdir 创建文件夹（目录）thedir // make directory/folder/path
      * rmdir 删除文件夹 只能删除空的 remove directory
      * rm 删除文件
      * rm -r thedir 删除thedir及其内容 ，递归删除
      * cp a.txt b.txt 复制
      * mv old new 移动（相当于剪切） 
      * touch a.txt 创建（空）文件
      * //chmod 文件权限控制
      * time command
      * 计算某命令的运行时间
      * date
      * 显示时间和日期
      * cal
      * 显示日历
      * //scp
      * //ping ip 测试与目标ip的连通性 （ping baidu.com)
        * sudo mkdir dir
        * gitlab删库事件
    
### vi编辑器
  * 基础使用
  * 达到可以在vps上编辑文本文件即可
  * esc 从编辑模式返回常规模式
  * i 常规模式下进入编辑模式
  * :wq 常规模式下输入

        
        
    
   
## vscode的常用快捷键 
 
* 注释快捷键
  *  单行注释：[ctrl+k,ctrl+c] 或 ctrl+/
  *  取消单行注释：[ctrl+k,ctrl+u] (按下ctrl不放，再按k + u)
  *  多行注释：[alt+shift+A]
  *  多行注释：/**
* 其他快捷键
  * Ctrl shift L 选中所有光亮区域
  * 移动行：alt+up/down
  * 代码格式化：shift + alt +f
  * HOME 调转到行头
  * end  调转到行尾
  * 显示/隐藏左侧目录栏 ctrl + b
  * 复制当前行：shift + alt +up/down
  * 删除当前行：shift + ctrl + k
  * 行增加缩进: ctrl + [
  * 行减少缩进: ctrl + ]
  * 删除行 ： ctrl + shift + d
  * 折叠代码： ctrl + k + 0-9 (0是完全折叠)
  * 展开代码： ctrl + k + j (完全展开代码)
  * 快速回到顶部 ： ctrl + home
  * 快速回到底部 : ctrl + end
  * 回到撤销之前：Ctrl +Y
  * 控制台终端显示与隐藏：ctrl + ~
  * 查找文件/安装vs code 插件地址：ctrl + p
  * 新建一个窗口 : ctrl + shift + n
  * 字体放大/缩小: ctrl + ( + 或 - )
  * 裁剪尾随空格(去掉一行的末尾那些没用的空格) : ctrl + shift + x
  * 拆分编辑器 : ctrl + 1/2/3
  * 切换窗口 : ctrl + shift + left/right
  * 关闭编辑器窗口 : ctrl + w
  * 关闭所有窗口 : ctrl + k + w
  * 切换全屏 : F11
  * 自动换行 : alt + z
  * 显示git : ctrl + shift + g
  * 全局查找文件：ctrl + shift + f
  * 显示相关插件的命令(如：git log)：ctrl + shift + p
  * 选中文字：shift + left / right / up / down
  * 快速切换主题：ctrl + k / ctrl + t
  * 格式化选定代码 ：ctrl + k / ctrl +f

# HTML补充知识
  ## name and id
   * name只有一些标签可以使用，可重复。可配合target使用，使新网页的地址为name的父标签（eg <iframe name="sfds"> <a target="sfds"> 
   * ID每一个标签都可以，不可重复。重复只调用前面的ID
   * class可以重复，而且只可以为多个，表示属于多个类 (class ="asdf  sfsdf  fsfsa") 

## 常见属性配合
   * <label for="iso"> <input  id="iso">
   * <a target="xm">  <iframe name="xm" >
   * <form action="https://www.google.com/search" target="_blank" method="get">
     <input type="text" name="q" >  <!-- 谷歌的默认name为q -->
     <input type="submit">
     <!-- 其他页面引入Google搜索 -->
   * <a href="#whoami">跳转本页的底部</a> <input id="whoami">  <!-- 指定跳转位置 -->
   * <img usemap="#somemap"> <map name="somemap">

 ## 小技巧   
   * 可以为一些元素增加一个自己的属性，名字和值都由自己决定（abc=123），然后可以用属性选择器击中该元素[abc=123]

## 其他小知识
   * 给html元素设置宽高百分比，是相对于视口而言的。如900*1080的视口，height:100%时高度就是1080，视口大小改变，html宽高随之改变
   * body是一个特殊的元素，不能通过overflow：hidden达到BFC效果。
   * html或body如果设置了背景颜色，那么这个颜色会覆盖整个窗口（无论设置的html或body元素的区域有多大），区域外的颜色优先和html的一致，如果html没有设置背景颜色，则区域外的颜色和body一致

# CSS知识汇总
 ## CSS编写规范
   * CSS外部文件修改完后在}后面加回车键，方便后期git diff 查看准确的修改提示（Windows换行符CRLF ，Linux换行符LF）
     *换行在开发中本身就是一个字符，CSS代码写完之后不加换行符，在下面的新代码开头写换行符时，相当于在CSS代码后面直接加换行符，这样在开发git diff 检查代码时会给开发人员造成困扰.
   *  CSS中，  ，号前后的选择器没有任何联系.  div>a , p{}  div的子元素和p标签，而不是div后代中的(p和a),CSS中不能有改变优先级的（）。
   *  CSS属性选择器中， 冒号描述的是紧挨着其前面元素，如果前面紧挨着空格，则描述的是某元素的后代。如果前面紧挨着class或者ID，先选择元素再在元素中寻找对应的类或者ID。
      *  div .bat.adf:first-of-type   先寻找div后代中的first-of-type ，再在筛选出的标签中寻找符合.bat.adf的类标签
   * :nth-child()和 :nth-of-type()的差别
     - span:nth-child(n)  父元素的第n个子元素且标签名为span
     - span:nth-of-type(n)  父元素的所有span子元素中的第n个span
     - 共同点—前面不要紧挨着类选择器：如果其前面紧挨着的是类选择器(.abc:nth-of-type(2)),他不会去找拥有这个类名的元素的第二个，而是先去找这个类对应的元素，找到之后忽略类名的限制，再去选择第二个该元素；

   * a标签的伪类最好顺序  link visited focus hover active  ,为了a标签的每一种状态都有交互效果（这几个优先级一样，但是浏览器会先执行后面的伪类）
   * 属性类选择器[属性=值]
     :not  选择器取反    not紧后面不写层级选择器的空格和其他表示层级的符号
     $=   结尾=
     ^=   开头=
     *=   任何位置=
     ~=   完整单词=
     [lang|= "en"]等同于 [lang="en"]+[lang="en-"]  ，表示以en开头或者以en-开头
   * CSS选择器只能由前面的元素现在后面的元素，不能反过来。

##  层级选择器
   *    . 表示类选择权
   *     #号表示ID选择器
   *    .foo.bar  值为foo且为bar的类(class="foo bar")
   *    .foo .bar空格表示后代选择器
   *    div > p     >号表示子元素选择器
   *    div + p + p  邻接选择器，只选择1个紧邻着的兄弟标签
   *    div ~ p      div后面的所有兄弟p标签

 ## 选择器的优先级
  *  第一：!important(优先级最高)
      第二：(内联样式，   #，     类选择器/属性选择器/伪类选择器,   元素选择器（标签选择器）/伪元素选择器)
      第三：继承（即使是继承下来的！important也是没有优先权的）          
  * 优先级的定义，四个数
      * (0，4，4，29)
      * (0, 6, 1, 0)
  * id选择器    #foo #bar #baz {} 
      * 0，1，0，0
  * 类选择器，属性选择器，伪类选择器
      * 0，0，1，0
  * 元素选择器（标签选择器），伪元素选择器
      * 0，0，0，1
  * 连接符如 > + ~ 等不参与优先级的计算
      * 于是 p a 与 p > a 的优先级是一样的
  * 通配符 *
      * 优先级为 0，0，0，0
      * 所以以下选择器的优先级是一样的
          * div p      div的所有后代的p元素
          * div * p      div的孙子及其后代的p元素
  * 内联样式/行内样式/行间样式/inline style
      * 1，0，0，0
      * <p style="color: green;">
  * ！important
      * p {color: red !important;}
      * 有与important冲突的属性，important都会占上风
  * 继承
      * 没有优先级，比【*】的优先级还要小

* 层叠样式
            双方选择器优先级排序一样时，看important的来源
      * 第一：最终用户important样式
      * 第二：网站作者important样式 authored style
            
            双方选择器优先级排序一样时，没有important时，看样式来源
      * 第三：作者普通样式
      * 第四：用户普通样式 Custom.css

      * 第五 默认样式，浏览器内置样式，User Agent Style（最低）

       * 浏览器HTML默认body大小为16px 
* 调整优先级的小技巧（重复就完事了）
  -     #AA可以写作#AA#AA#AA  (0,1,0,0)变为(0,3,0,0)
  -    .AA可以写作.AA.AA.AA  (0,0,1,0)变为(0,0,3,0)
  -    .a:hover可以写作.a:hover:hover:hover   (0,0,2,0)变为(0,0,4,0)

## 盒子模型
  * 左边界+左边框+左填充+content box+右填充+右边框+右边界=父元素内容区宽度
    上边界+上边框+上填充+content box+下填充+下边框+下边界=父元素内容区高度
  * content box（文本盒子，没有文本时其尺寸为0）--padding box--border box（可见区域）----margin box（不可见，不可交互）  
  *  width的默认值为auto，margin和padding一般默认为0；
     标题，列表，表格等元素一般有默认的margin或者padding
  * background-color说的是border box的背景颜色
  * background-image默认从padding box的左上方开始平铺背景图片
  * outline属性，位于border外围，紧贴着外边框，可起到突出元素的作用，不影响网页布局。
  * padding/border的值不能为负值,margin可以为负值 
  * width/height默认设置的是content box的宽度
    * box-sizing：border box/content box , 默认值为content box，声明宽高是哪部分盒子的尺寸（目前只有2种盒子可选）
  * 边框的其它样式设置了但是颜色没有设置，这时边框颜色默认为元素内容的前景色（即字体颜色颜色，不是背景色）
  * 包含块：一个元素的包含块是离该元素最近的块级祖先的content  box
    * 初始包含块： viewport(html的包含块)
  * 正常流： Normal Flow，从左往右，由上往下
  * 一个块元素没有内容时，默认margin padding border content都为0 
  * 如果border-left足够粗，是一个梯形，内容区为0时变成了一个三角形。
  * 在CSS中，两个或多个毗邻（父子元素或兄弟元素）的普通流中的块元素垂直方向上的 margin 会发生叠加。这种方式形成的外边距即可称为外边距叠加(collapsed margin)。
    两个盒子相邻，两个正margin重合，取其中最大的margin为合并后共用的margin.
    两个盒子相邻，两个负margin重合，取其中绝对值最大的margin为合并后共用的margin.
    两个盒子相邻，两个正负margin重合，取正负相加的值为合并后共用的margin.
    创建BFC和通过对父元素建立border，padding，或者间隔可以使外边距不合并；
    水平方向margin不会合并，左右margin  会紧挨着排列；
  
## 正常流块元素水平布局（margin-right/left，width）
  *  没有auto
      过分受限，重置margin-right为auto（做右往左的语言会把margin-left设置为auto，比如说阿拉伯语言）
  *  一个auto
      算出它
  * 两个auto
      两个margin为auto，计算为相同的值，水平居中的方法
      其中有一个auto给到了width，margin的auto为0
  *  三个auto
      两个margin都重置为0
  *  margin-left为auto时无法计算出负值（对于从左往右的语言）
  *  max-width 最大宽度
      min-width  最小宽度
      搭配width为auto时使用
  * 替代元素中的块元素的width由块元素自身决定，默认值不为auto.(比如img，引入的图片默认宽度由图片自身决定，高度成比例变化)
## 正常流块元素垂直布局（margin-bottom/top，height）
  * 包含块的高度默认auto，由其宽度和子元素的高度等等填充起来
  * 垂直方向margin-bottom/top都为auto时，不会垂直居中，而是auto都为0
  * margin和padding的百分比是基于包含块文本框（content box）的宽度，上下左右都是如此；可以利用padding的这一个特性来实现宽高定比例；
  * 当包含块的高度不确定时，且其高度是由其内容区撑大时，margin和padding的高度不能写成百分比；逻辑错误
  * 当包含块的高度确定时，或者其高度不由内容区撑大（如定位），可以使用百分比
  * 当一个包含块里面都是块元素时，包含块没有设置border和padding时，包含块的高度就是里面最上面块元素上边框到最下面下边框的距离；

## BFC/块格式化上下文（Block Formatting Context，BFC）
  * 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。
  * 在常规流和float里面有效，不能包着脱离常规流的定位元素
  * 常规流块元素没有边框和内边距时，包裹着子元素的border-box，父子元素的margin会合并
  * 触发了BFC的元素，无论如何都会包裹着其子元素的margin-box，父子元素的margin也不会合并
  * 下列方式会触发BFC：
    浮动元素（元素的 float 不是 none）
    绝对定位元素（元素的 position 为 absolute 或 fixed）
    行内块元素（元素的 display 为 inline-block）
    弹性元素（display为 flex 或 inline-flex元素的直接子元素）
    表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）
    display 值为 flow-root 的元素
    overflow 值不为 visible 的块元素
    表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）
    匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）
    contain 值为 layout、content或 strict 的元素
    网格元素（display为 grid 或 inline-grid 元素的直接子元素）
    多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）
    column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。

## 定位 position
   * 默认值static，表示常规流。
   * 定位指的是margin box定位到对象的padding box 
   * 固定定位 fixed
      相对于视口固定 ，不随滚动条滚动，脱离常规流
   * 相对定位 relative 
      相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。相对自己定位，原来的位置保留在常规流
   *  绝对定位  absolute
      相对于最近的定位祖先定位，如果祖先没有定位，相对于第一屏（滚动条在最上方时的可视窗口）定位，脱离常规流
   *  粘性定位 sticky
      粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定值前为相对定位，之后为固定定位。在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下；当其包含块的文档区脱离视口时，它会被包含块带走。元素在常规流的位置保留
      #one { position: sticky; top: 10px; }
   * 层叠覆盖关系
     * 定位流盖住常规流    
     * 后出现的定位流元素盖住前面定位流元素。所有定位脱离常规流的元素都在一个层面，在同一个位置上，后出现的元素会盖住前面的元素，需要设置z-index改变叠层  
     * z-index  必须配合定位使用
       * 调节层叠覆盖关系，常规流默认值为0
       * z-index:值；   值大的盖住值小的，可以有负值，都为整数。
    * 常用布局
      * 元素明显重叠时，可用定位实现
    * 元素的方位
      top left right bottom
      当不明确指定时，元素的从它在常规流中开始的位置开始。
      4个方位的值表明的是离其定位对象四周的距离
      取百分比时，百分比相对于包含块（或定位祖先）的padding-box的对应尺寸

## 行内布局
  * 基本术语和概念
    * 匿名文本：直接包在块元素的文本，继承父元素的line height高度数值 
    * em框：也叫字号框，font-size决定其高度
    * 内容区：多个字号框拼接在一起组成了内容区（content area)，内容区被该元素的border包围，和border box类似
    * line height框：假想概念，高度为行高，内容区和其共用一条居中线。
        * 包含块行高等于其高度，其内部文本和inline元素垂直居中；
        * 当line-height的值为数字或者百分比时，表示用字体的大小乘以数字或者百分比
    * 行间距：line-height  -   font——size
    * 行内框：对于非替换元素，行内框就是line height框；
              对于替换元素，行内框就是marginbox，
    * 行框：用最小的框将每一行所有的行内框包裹起来，这种框就是行框；上下行框紧紧挨着形成布局，如果父元素是块元素，行框撑起了父元素的高度；
            行框和line-height和vertical-align有关。
    * margin border padding不会影响垂直方向的布局

  * 空格的大小和字体一致，字体为0时没有空格。

  * 模型：
    行内框在一行以内水平排列，空间不够后就折行
    一行的所有行内框形成行框
    行内框可以通过vertical-align做垂直微调
  * 一个行内元素跨行会生成多个盒子
  * 匿名文本
    所在属块元素的line-height框
  * display: inline
    行内框也是仅通过line-height框确定
    所有额外的padding，border不影响行内框的生成
    对inline元素设置宽高无效
    当inline元素无padding及border时，其底色区域的高度为当前字体line-height为normal时的计算值，与实际设置的line-height无关。
  * display: inline-block/table
    inline-block元素内部没有文字或者触发BFC时，行内框为margin-box的外边缘；
    inline-block元素内部有文字时，通过文字来调整对齐；
    基线为最后一行文字的基线/无内容时以m-box下边缘为准
    考虑其自身位置/摆放时，当成图片考虑
    考虑其内容的布局时，当成块/表
  * 只要行框形成，就要考虑那一行有一个匿名文本
  * 对于替换元素（图片）
    设置display：inline无效，会当成inline-block；


  * vertical-align ：指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。
    baseline(默认值)
    使元素的基线与父元素的基线对齐。HTML规范没有详细说明部分可替换元素的基线，如<textarea> ，这意味着这些元素使用此值的表现因浏览器而异。
     * 当元素设置为inline-block时，并且其overflow的值不为visible，此时baseline对准的是其margin-box边缘
    middle
    使元素的中部与父元素的基线加上父元素x-height（译注：x高度）的一半对齐。
    *而当字体大小为0时，基线的位置就等于中线的位置,设置垂直居中时可以用到
    top
    使元素行内框的顶端与行框的顶端对齐。
    bottom
    使元素行内框的底端与行框的底端对齐。
    text-top
    使元素的顶部与父元素的字体在lineheight=normal时的顶部对齐。
    text-bottom
    使元素的底部与父元素的字体在lineheight=normal时底部对齐。
    sub
    使元素的基线与父元素的下标基线对齐。
    super
    使元素的基线与父元素的上标基线对齐。
    percentage
    使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数。
    <length>
    使元素的基线对齐到父元素的基线之上的给定长度。可以是负数。

 

## 表格
   *  table    =  display:table   
      tr       =  display:table-row   
      thead    =  display:table-header-group   
      tbody    =  display:table-row-group   
      tfoot    =  display:table-footer-group   
      col      =  display:table-column  
      colgroup =  display:table-column-group  
      td,th    =  display:table-cell   
      caption  =  display:table-caption   
   *  col/colgroup 的可用样式只有border,background,width,visibility

   * 表层 table--colgroup--col--tbody--tr--td，由小到大
   * border-collapse:collapse  边框合并，默认为separate，不合并；  合并之前只有table和td可以设置边框，合并后tr tbody col colgroup都可以设置边框，但是在同一个位置的边框都会合并。
     合并规则：1 值为hidden优先级最高，值为none优先级最低。
              2 优先级顺序（宽度:谁宽谁优先，   样式：double--solid--dashed--dotted，     颜色来源：和表层一致，         位置：左上方大于右下）
   * table-layout：fixed； 设置表格宽高需要这个属性   
   * 表格单元格自动垂直方向居中，为table设置text-align为center可以水平垂直居中
   * 单元格的宽高都会默认内部文本不会超出；例如为左右两个cell设置width分别为1%和100%；，左边的cell会尽量小，右边cell尽量宽，但是会忽略其比例，因为要保证其内部文本不超出。    若左右两个cell设置width分别为40%和60%，而且空间足够包裹文字，则两边cell的比例就为4:6；
   * empty-cells：设置空单元格是否隐藏

## 浮动
  * 浮动元素的布局盒子也是margin box
  * 块级元素无法感知浮动元素，行内元素可以感知到并且避开布局盒子。处于半常规流，和fixed和absolute一起用时不生效，和relative一起用时先浮动再相对定位。
  * 浮动元素下移之后就不会再上移了，可以左移或者右移，
  * 触发BFC浮动元素不会超出其包含块。触发BFC的块元素周围有浮动元素时，为了避开浮动元素BFC元素会变窄
  * 在常规流中，行内元素盖住浮动元素，浮动元素盖住块级元素

  * 浮动元素规则
    -浮动元素的左右外边界不能超出包含块的左右内边界，浮动元素不会超过容器的上padding 
    -当浮动元素的width>容器的width时，这会使得浮动元素超出容器的左右边界，但它会向下移动到保证超出的部分最小。
    -同一个包含块内浮动元素之间不能互相重叠
    -元素浮动后会生成块级框，即浮动元素没必要指定display:block
    -浮动是在离其最近的块级祖先包含块中浮动
    -浮动元素尽可能往上浮动
    -浮动元素不能比前一个块级元素或浮动元素高。
    -浮动元素的下边界没有要求，因此当容器不足以容下浮动元素时，浮动元素会向下延伸。这时可以用到闭合浮动

  * 清除浮动：clear元素，用于块元素，使其下移到两边没有浮动元素。块元素的border box和浮动元素的marginbox紧挨着；
  * 闭合浮动：某个块框通过增加自己的高度使其能够包含其浮动的后代元素（通过自己变大，使所有后代浮动元素被自己包起来）
    闭合浮动的方式
    * 触发BFC：
      overflow: hidden/auto/scroll;
      display: inline-block/table-cell/table/flow-root;
      position: absolute/fixed;
      float:除none 以外的值;
    * 在末尾使用一个行内元素生成的行框将其撑高
      缺点：会生成一个行框，有一定的高度
      font size=0,line height=0
    * 在末尾使用一个clear:both的块元素将其撑高
      优化：用after伪元素




##  CSS补充知识
  ### 伪元素
  * div::before（位于开始标签之后）     div::after（位于结束标签之前）
    这两个伪元素都是div的子元素 ，且都为行内元素，直接在CSS中使用。
    ::selection {被鼠标选中的文字，只能设置前景色和背景色}
    ::target {选中id的值为地址栏中#后的内容的元素}

  * 伪元素后面不能加伪类，只能加在其父元素后面
    div:hover::before  对
    div::before:hover  错
       
  * 伪元素的属性
    * content属性，必要属性，它的值是文字或者空值，多个值之间用空格分开  content："" "asf" attr(父元素的属性) '空格'  ；
      attr(父元素的属性) = 父元素的该属性值                    /A 回车    

      
 ### 回流与重绘 
   * 回流 reflow relayout
      页面样式的变化涉及到重新计算布局
      在可能的情况下不要触发回流或把回流控制在一定的范围内
      因为回流速度更慢
    * 重绘 repaint
      速度快
      页面样式的变化不涉及布局的计算，只变了颜色，背景，阴影等不影响布局样式 

 ### 新元素和属性收集
   * pointer-evens
     默认值为auto，鼠标可以交互
     值为none时，鼠标在对象里面无法交互，但是会指向其后代
   *  visibility，支持动画
      默认值visible，可见
      hidden 内容隐藏，位置还在,display:none无法支持动画，可选择visibility属性
      collapse 用于 <table> 行、列、列组和行组，隐藏表格的行或列，并且不占用任何空间（与将 display: none 用于表格的行/列上的效果相当）
   * min-height/width   max-height/width  设置元素宽高的最大最小数值  ，浏览器的窗口不是html元素，浏览器的窗口大小不能由这两个属性控制，有浏览器默认控制。
   * clip-path CSS 属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。 
     clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);  不规则图形，四个坐标对应4个点；
    * 列表图标
      list-style-image:url() 图片会原比例尺寸插入，无法调整大小和位置，几乎不用 
      list-style-position:inside ：设置图标在li`边框的内外部
      list-style-type:decimal：设置图标的样式，圆，方块，10进制等
    * <link  media="print"> 设置代码在哪种设备中生效  
    * 计数器 counter
      counter-increment: 计数器名（遇到该计数器开始计数）  数字（加几，默认1） 
      counter-reset：计数器名(遇到该计数器重置)  数字（重置为几，默认0）
    * 打印断页
      page-break-before：avoid/always    该标签前面不断页/断页
      page-break-after :avoid/always    该标签后面不断页/断页
      page-break-inside : avoid    该标签永远在一个页面里面
    *  all:initial 所有属性回到初始值，即浏览器默认值 
    * 为所有元素设置box-sizing较好的方法
      html {
      box-sizing: border-box;
      }
      *,::before,::after {
      box-sizing: inherit;
      }
    * background-clip :border-box/padding-box/content-box
      设置元素的背景（背景图片或颜色）是否延伸到边框下面。  
      background-size：contain 缩放背景图片以完全装入背景区，可能背景区部分空白/cover缩放背景图片以完全装入背景区，可能背景区部分空白/百分比/px值
      

## CSS3知识
  * 以前对于目前有争议不兼容的属性，不同的浏览器加上不同的前缀，现在这种做法已淘汰
    -ms-属性：值         IE浏览器
    -webkit-属性：值     Chrome浏览器
    -moz-属性：值        火狐浏览器
  * 对于大型商业网站，pc端一个网站，移动端一个网站，两个团队开发
    对于简单的网站只用一个站点，配合media query 让站点在不同的设备上展示比较合适
### media query
  * media query语法
    - 使用link插入外部样式表
      <link  media="logic media and (expression)">
    - 使用@import指令调用外部样式表
      @import url() logic media and (expression)
    - 直接在css区域插入
      @media logic media and （expression）{css语法}  
  * media query不会增加选择器的优先级
  * @media(max-width:500px){rule} 小于500px生效
    @media(min-width:500px){rule}  大于500px生效
  * 像素比：css像素比上物理像素。DPR   device pixel ratio
    手机上一般为3，即手机上一个css像素对应3个屏幕物理像素,更多用dppx表示 dots per pixel ratio
    @media media and (resolution:3){css语法}

### web font
  * @font-face规则
    @font-face{
      font-family:字体名字；
      src:local('相对地址')，url('绝对地址') format('字体格式')
    }
   为了更好的兼容各大浏览器，我们一般做多次@font-face声明，并且每次声明至少写3种字体格式 

  * 防止页面加载时因为引入CSS延时产生的抖动
    - 把第一页的样式放在html里面
    - 把link标签写在最上面（link标签可以写在任何位置）

  * 好用的图标字体网站
    https://www.iconfont.cn 下载图片格式的图标
    https://fontawesome.com/   下载css文件后引用

### 文本排版
  * text-shadow: 文本阴影 和box-shadow类似
    （x偏移，y偏移，模糊半径，颜色）可写多组数值来表现多重阴影，每组值用逗号隔开；
  * resize:horizental/vertical/both/none  设置元素大小能否被鼠标控制拉伸，只控制自己，不递归控制
  * word-wrap:normal/break-word  设置长单词能否被折断
  * text-wrap ：normal（默认）/none 设置文本行能否被折断，none表示所有文本行写作一行
  * text-indent 属性 规定了 一个元素 首行 文本内容之前应该有多少水平空格。
  * white-space：nowrap    设置文本内容不折行
  * word-space:12px; 设置行内元素之间的间距

  


###  移动端的适配方法  
  * <meta name="viewport"  content="width=device-width" >  利用px开发
    <meta name="viewport"  content="width=360" >可以个定值 ，不需要单位 。
    让手机浏览器以多少宽度的初始快包含块来渲染页面，如果不加这个标签，手机会以宽度1000px左右包含块来渲染页面，目前移动端流行为360；
  * 所有布局宽高都使用vw，这样布局的视觉效果和移动端的具体宽度无关了
  * 使用rem单位； 等比适配,
    1rem=100a
    设置x*a=100vw;
    x为视觉口的宽度（开发时设计人员给的值），100vw是移动端的宽度，可以用js直接测出来，这样就可以算出rem的值，所有布局宽高都使用rem为单位；
    一般rem默认最小为12px,上面算出的a比较小，所以我们一般乘以100倍来表示新的rem,即1rem=100*100vw/x ,然后将量出的视觉稿布局尺寸y除以100即可，那么对应的屏幕布局尺寸
    z=y/100   *  100a=y/100   * rem 

  *总结
    移动端布局：
    viewport标签仅被移动端浏览器支持
    PC端浏览器的渲染窗口即为窗口大小减去额外浏览器自身元素
    如果没有viewport标签，移动端浏览器会主以980像素的浏览器窗口渲染页面（即手机浏览器宽度为980px)
    如果有，如果viewport写为width=X，则移动端浏览器就以Xpx为初始包含块渲染页面
    如果写为width=device-width，则移动端浏览器会以出厂设置的宽度为初始包含块的宽度渲染，出厂设置的值一般来说与屏幕物理尺寸正相关，范围一般为320到400左右，目前最主流的是360

    假定视觉稿宽度为X
    对于针对移动端的页面，一般有两种情况：
      *. 页面较复杂，希望页面在不同的手机上效果和比例一致（mi.com移动端）
        页面需要等比缩放，即视觉稿宽度跟浏览器/手机屏幕一样宽
        且我们希望从视觉稿里测量出来的数据能直接用在代码里
      - 所有用户的设备都支持设定视口宽度的产品来说，直接把视口宽度设置为视觉稿宽度，页面使用px为单位开发，数值直接从视觉稿量出来
         如<meta name="viewport"  content="width=360" >
      - 对于并不是所有用户的设备都支持设定视口宽度的产品来说，我们同样希望视觉稿里测量出来的数据可以直接用在代码里，于是要找一个可以灵活缩放的单位（因为不同的手机窗口宽度不一样），让X倍的这个 单位正好等于宽屏宽度
        Xrem = 100vw
        rem = (100vw / X)
        html {font-size: calc(100vw / X)}
        有些浏览器不允许最小字号小于12px，而上面的公式算出来的值过小，会被重置，所以将其放大100倍，即
        html {font-size: calc(100vw / X * 100)}
        还有些浏览器不支持calc/vw，所以这个值通过js读取出浏览器视口的宽度并自行算出，然后设置到html元素上
        之后从视觉稿量出来的尺寸将小数点移动两位后加rem单位即可用在代码里。

    *. 页面较简单，希望页面在更大的手机上显示更多的内容（github移动端）
        直接使用device-width且使用px以及流式布局（块元素自动占满宽度）

    *. 对于杂合形页面，即布局复杂，又有很多文字
        布局使用rem，文字使用px，width=device-width


###  多列
   * column-count:2/3; 设置文本分成多少列，和column-width一起用时表示最大多少列
     column-width：150px； 每列的最小宽度
     column-count，column-width一起使用时，先满足column-width的要求，
   * column-gap：2em ;每列之间的间隙
     column-rule: 2px solid red  ;  设置每列之间的垂直分隔线
   * column-fill：balance（默认值）/auto  ;设置填充方式
     balance表示每列平均填充文本；auto表示按照顺序填充，一列填满后再填下一列
   * break-inside:avoid-column; 使同一个元素在一列中显示，不要左右断开显示
   * column-span：1/all;
     默认值为1，使行内元素可以分列；值为all时，行内元素占据整行不分列；
   * 多列属性元素的行内子元素无法撑开其宽度，父元素的宽度为行内子元素不分列时的宽度。  

### 边框及边框效果
  * border-radius:x1 x2 x3 x4/y1 y2 y3 y4
    border-top-left-radius:x1 y1
    border-top-right-radius:x2 y2
    border-bottom-left-radius:x3 y3
    border-bottom-left-radius:x4 y4
    表示正圆形时x和y的值一样，写一个值即可；border-radius：x1 x2 x3 x4
    border-radius：9999px,   值足够大就是4个圆角（上下或者左右角半径之和大于边框长宽时会等比缩小）
    border-radius：100%， border-box不为正方形时，为椭圆（百分比是以边框为基础的）
  * box-shadow ：/* inset（向内扩散，不写就默认向外扩散） | x偏移量 | y偏移量 | 阴影模糊半径| 阴影扩散半径 | 阴影颜色 */

### 颜色和透明度

 * opacity ：0~1  透明度
     *不能继承，父子元素都有透明度时，先将子元素透明好，再透明父元素，父子元素的透明度在子元素的位置会叠加
     * 会通过触发图形加速，单独形成一个图层和当前图层重合，默认通过图形加速的图层会盖住常规流。比如浮动元素opacity属性触发图形加速后会盖住常规流。
     * 通过触发图形加速单独形成一个图层在显卡中进行图形变换，这样工作效率高，效果好。

### 渐变
  * linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于<gradient>数据类型，是一种特别的<image>数据类型。
    background-image：linear-gradient(to left ,white,black)  由白到黑向左边渐变
    linear-gradient(渐变方向，可以为弧度角度    ，   开始颜色 ，  结束颜色) 
  * radial-gradient() 径向渐变；颜色值由一个中心点（原点）向外扩散并逐渐过渡到其他颜色值。
  * 重复渐变; 重复多次渐变图案直到足够填满指定元素。由 repeating-linear-gradient()和repeating-radial-gradient()函数产生。

### 2D变换
  * 线性变换，有规律可循；默认x轴箭头向右，y轴箭头向下
  * transform：function（value）function（value）function（value）
     * 变换的元素会通过显卡(GPU)渲染，单独形成一个图层，覆盖常规流，但是常规流只能感受它变换之前的位置，无法感知现在的位置，不影响常规流布局
     * 第一个函数变换后，以更新后的位置为基础进行下一次函数变换 
     * transform里面变换前后函数的数量和顺序一样时，不是起点和终点的直线变换，而是按照每个变换点一步一步的渐进变换
  * transform-origin：不动点，元素围绕改点进行变换
    * 默认值为元素水平垂直的中点，注意此时其坐标不是（0,0）
    * （0,0）坐标在元素左上角
    * 表达方式 
      transform-origin：x, y
      transform-origin：100%, 100%
      transform-origin：left, top
      transform-origin：center, center
  * transform:rotate(度)  旋转 ；元素坐标系跟着旋转
  * transform:translate（）平移;会把不动点一起平移
    * transform:translate（x, y）
      transform:translatex
      transform:translatey
    * 水平垂直居中
      - 先绝对居中到父元素的中心（top：50%；left：50%）
        再向上和向左平移自身的50%（ transform:translate（-50%, -50%））
  * transform:scale() 缩放，会把自身的坐标缩放
    * transform:scale(x,y)分别在水平垂直方向缩放
      只有一个值时，x和y共用这一个值
  * transform:skey()   倾斜坐标轴一定的角度
    * transform:skey(x , y)
  * transform：matrix()  矩阵变换
    所有的变换最终都是综合为一个矩阵变换

### 3D变换
  * transform-origin：x,y,z;  设置不动点的位置
  * transform-style：flat（默认值，平面拉伸）/preserve-3d(设置该值有3D深度感)
  * Perspective景深，眼睛离平面的垂直距离，可以继承，近大远小；
    transform：perspective（1000px/none），值为具体数值或者none；该函数只能写在最前面，写在后面会被忽略；
    perspective-origin：x,y;  设置观察点相对于平面的位置
  * transform:rotateX/Y/Z()
    transform:rotate3d(x,y,z,度数);  (x,y,z)表示矢量坐标，元素围绕该矢量线旋转
  * transform:translateX/Y/Z()
    transform:translate3d(x,y,z)
  * transform:scaleX/Y/Z()
    transform:scale3d(x,y,z)
    z的值默认为0，不设置Z的值就相当于进行2D变换
  * transform：matrix3d()  3D矩阵变换
    所有的3D变换最终都是综合为一个3D矩阵变换

### 过度与动画
   * transition  平滑的改变CSS的值 （可以简写，保证duration在delay前面即可）
     - transition-property
       指定过渡的属性值，比如transition-property:opacity就是只指定opacity属性参与这个过渡。默认值为all
     - transition-duration
       指定这个过渡的持续时间
     - transition-delay
       延迟过渡时间，双向的，开始动画之前和动画结束之后都是有delay时间
     - transition-timing-function
       指定过渡动画缓动类型，有ease | linear | ease-in | ease-out | ease-in-out | step | cubic-bezier()贝塞尔曲线
       其中，linear线性过度，ease-in由慢到快，ease-out由快到慢，ease-in-out由慢到快在到慢。
   * animation 动画（可以简写，保证duration在delay前面即可）
     - @keyframes  name {关键帧（10%）{属性：值}  关键帧（10%）{属性：值} 关键帧（10%）{属性：值}}
       —关键帧可以用百分比，也可以用to(100%)和from（0%）
     - animation-name：关键帧前面定义的name
     - animation-duration :持续时间
     - animation-timing-function 关键帧的过度动画缓动类型
     - animation-delay  动画延迟
     - animation-iteration-count  动画执行次数  默认为1次，infinity表示无数次
     - animation-direction:normal(默认值，1次播完突变回来)/alternate(表示动画会反着播放回来，1次结束后不会突变回来，并且回来的这次也算次数)
     - animation-fill-mode:设置CSS动画在执行之前和之后如何将样式应用于其目标。
        -none 当动画未执行时，动画将不会将任何样式应用于目标，而是已经赋予给该元素的 CSS 规则来显示该元素。这是默认值。
        -forwards 目标将保留由执行期间遇到的最后一个关键帧计算值。
        -backwards 动画将在应用于目标时立即应用第一个关键帧中定义的值，并在animation-delay期间保留此值。
        -both 动画将遵循forwards和backwards的规则，从而在两个方向上扩展动画属性
     - animation-play-state:动画播放状态  running(播放)/paused(暂停)

 ### Blend Modes/Filter/Masking 
   * background-blend-mide  设置背景的颜色混合方式
     mix-blend-mide 设置多个元素的颜色混合方式
     isolation：auto/isolate 该属性的主要作用是当和background-blend-mode属性一起使用时，可以只混合一个指定元素栈的背景
    * filter滤镜 
        filter: blur(5px);  模糊
        filter: brightness(0.4); 亮度
        filter: contrast(200%);  对比度
        filter: drop-shadow(16px 16px 20px blue); 阴影效果
        filter: grayscale(50%); 将图像转换为灰度图像
        filter: hue-rotate(90deg); 给图像应用色相旋转
        filter: invert(75%); 反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。
        filter: opacity(25%); 转化图像的透明程度
        filter: saturate(30%); 转换图像饱和度。
        filter: sepia(60%)  将图像转换为深褐色
    * mask 允许使用者通过部分或者完全隐藏一个元素的可见区域。这种效果可以通过遮罩或者裁切特定区域的图片。

### Flex 布局 
  *  知识来源： http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html
   * 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。任何一个容器都可以指定为 Flex 布局，行内元素也可以使用 Flex 布局；
     它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。
   * 相关概念：容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross        start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。  
   * flex也是在常规流的布局，当元素设置flex布局时，先进行常规流布局，再在此基础上拉伸
 ####  Flex的相关属性
   * flex container相关属性
     * diplay:flex; 初始必要设置
     * flex-direction属性决定主轴的方向（即项目的排列方向）
        - row（默认值）：主轴为水平方向，起点在左端。
        - row-reverse：主轴为水平方向，起点在右端。
        - 当主轴为水平方向时，item的height默认值为100%；
        - column：主轴为垂直方向，起点在上沿。
        - column-reverse：主轴为垂直方向，起点在下沿。
        - 当主轴为垂直方向时，item的width默认值为100%；
    * flex-wrap属性定义，如果一条轴线排不下，如何换行。
        - nowrap（默认）：不换行。
        - wrap：换行，第一行在上方。
        - wrap-reverse：换行，第一行在下方。
     * flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap 
     * justify-content属性定义了项目在主轴上的对齐方式。
        - flex-start（默认值）：左对齐
        - flex-end：右对齐
        - center： 居中
        - space-between：两端对齐，项目之间的间隔都相等。
        - space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。    
     * align-items属性定义项目在交叉轴上如何对齐。
        - flex-start：交叉轴的起点对齐。
        - flex-end：交叉轴的终点对齐。
        - center：交叉轴的中点对齐。
        - baseline: 项目的第一行文字的基线对齐。
        - stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
     * align-content属性定义了多根交叉轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
        - flex-start：与交叉轴的起点对齐。
        - flex-end：与交叉轴的终点对齐。
        - center：与交叉轴的中点对齐。
        - space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
        - space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
        - stretch（默认值）：轴线占满整个交叉轴。
   * flex item相关属性
     * order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
     * flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
       - 所有item的flex-grow的值之和大于1时，所有的剩余空间按照值的比例分配。
       - 所有item的flex-grow的值之和小于1时，每个item分配到的剩余空间为总的剩余空间乘以flex-grow的值，即有部分剩余空间没被分配
     * flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 
       - 空间不足时该属性才生效，负值对该属性无效；
       - item缩小的权重是 其宽度（高度）乘以flex-shrink的值 ，缩小的距离即为该item所占的权重比例乘以整体的缩小距离；
         eg: [(300*2)/（400*3+300*2+500*4)](权重比例)*200(整体的缩小距离)
     * flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小；
       根据主轴的方向，flex-basis分别对应在width和height；
       flex-direction为row时，flex-basis为width
       flex-direction为column时，flex-basis为height
     * flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。
     * align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。

### 水平垂直居中知识汇总
   * 以下父元素称为包含块，子元素称为内容区
   * 包含块的line-height=height时，实现文字的垂直居中。内容区和行高共用一条居中线，当行高等于行框高度时，行高的中点也就是行框的中点；
   * 包含块text-align=center，使其内容区水平居中。
   * 包含块内容区margin=auto时，实现水平居中；
   * 行内元素vertical-align=middle,加上font-size：0，可以实现垂直居中。
     字符X在父元素中并不一定是垂直居中的，各个字体的字符X的高低位置不一致。所以，当字体大小较大时，这种差异就更明显。而当字体大小为0时，基线的位置就等于中线的位置，我们通过设置父元素的font-size:0来使图片达到完成垂直居中的效果 ；
   * 绝对定位时，设置内容区的上下左右都为0，margin为auto时也可以实现水平垂直居中；margin在这种情况下会自动调整，上margin等于下margin。左margin等于右margin
   * flex布局时，justify-content=center，align-items=center可以实现水平垂直居中
   * 利用表格时，table-cell自带垂直居中属性，为table设置text-align为center可以水平垂直居中
   * 利用translate平移属性
      先绝对居中到父元素的中心（top：50%；left：50%）
      再向上和向左平移自身的50%（ transform:translate（-50%, -50%））

### Sass   
   * 更多知识 http://www.ruanyifeng.com/blog/2012/06/sass.html
   * sass转化为css网站 https://www.sassmeister.com/
   * 类似于根一样的嵌套规则，@import命令，用来插入外部文件。如 @import "path/filename.scss";
   * &符号表示父选择器，可直接使用
   * 变量$ ,变量仅在它定义的选择器嵌套层级的范围内可用,加上!globle就是全局属性；
    　　$blue : #1875e7;　
    　　div {
    　　　color : $blue;
    　　}
   * 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。
      　$side : left;
    　　.rounded {
    　　　　border-#{$side}-radius: 5px;
    　　} 
    * 循环语句编辑（through包括最后一位，to不包括）
      下面表示子元素第1到第9个span的宽度为等差数列（20px, 40px, 60px....180px)
        　@for $i from 1 to 10{
            span:nth-child(#{$i}){
                    width:$i * 20px;
             }
          } 


# Bootstrap(CSS框架)
   * 直接用link引入<link href="url" rel="stylesheet" type="text/css"   integrity="完整性验证码（HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu）" >
  


# 布尔代数与逻辑电路

## 布尔代数

### 布尔代数其实就是命题逻辑的【形式化表达】

* 命题逻辑
	* 真命题
	* 假命题
	* 逆命题
	* 否命题
	* 逆否命题等

* 布尔代数中只有两个值，即真和假，一般表示为0和1，对应于命题逻辑里命题的真和假
* 当使用变量表示值的时候，一般使用【大写】的单个字母，如A，B等
* 布尔代数中的两个值可以进行如下简单的【基本运算】
* 逻辑与
	* 0 & 0 = 0
	* 0 & 1 = 0
	* 1 & 0 = 0
	* 1 & 1 = 1
* 或
	* 0 | 0 = 0
	* 0 | 1 = 1
	* 1 | 0 = 1
	* 1 | 1 = 1
* 非
	* !0 = 1
	* !1 = 0

* 常见非基本运算：
	* 异或
    相同为0，不同为1
		* 0 ^ 1 = 1
		* 1 ^ 0 = 1
		* 0 ^ 0 = 0
		* 1 ^ 1 = 0
	* 同或
    相同为1，不同为0
		* 异或的反运算
		* 0 ^ 1 = 0
		* 1 ^ 0 = 0
		* 0 ^ 0 = 1
		* 1 ^ 1 = 1
	* 与非
		* 先与后非
		* 0 NAND 0 = 1
		* 0 与非 1 = 1
		* 1 与非 0 = 1
		* 1 与非 1 = 0
	* 或非
		* 先或后非
		* 0 或非 0 = 1
		* 0 或非 1 = 0
		* 1 或非 0 = 0
		* 1 或非 1 = 0
		* 理论上，所有的逻辑运算都可以仅通过与非运算表达
			* https://zh.wikipedia.org/wiki/%E4%B8%8E%E9%9D%9E%E9%97%A8
      
* 逻辑非的多种表达方式：
	* V + 表示或   A+B
	* 反V AB 表示与   AB
	* 值上方加一横、或者A'、或者!A、或者﹃A，表示非A
* 通常为了方便表达、理解和书写，纯文本表达时，用加号（+）表示或，用乘号（*）表示与（有时为了方便也可省略点乘号直接写成AB），用叹号或单引号（!，'）表示非：A'，!A。手写时用上方加横表示非

* 常用运算法则(通过集合是思想去理解)
	* 幂等律
		* A + A = A
		* A * A = A
	* 有界律
		* A + 0 = A
		* A * 1 = A
		* A * 0 = 0
		* A + 1 = 1
	* 交换律
		* A + B = B + A
		* AB = BA
	* 结合律
		* A+B+C = A + (B + C) = (A + B) + C
		* ABC = A(BC) = (AB)C
	* 还原律
		* A = !!A
	* 摩根定律/反演律
		* !(A * B) = !A + !B
		* !(A + B) = !A * !B
	* 分配律
		* A * (B + C) = (A * B) + (A * C)
		* A + (B * C) = (A + B) * (A + C)
	* 其它 http://blog.csdn.net/yueniaoshi/article/details/8040119
* 逻辑表达式的真值表
	* 即把一个逻辑表达式的【所有变量的所有可能】及【此时表达式的值】全部列出来的一张表
	* A * B = ？
	* 0   0   0
	* 0   1   0
	* 1   0   0
	* 1   1   1
	* 例：
		* 用真值表证明前面各个运算法则
		* 反演律  也可以通过真值表反推运算规律
		* 分配律  
* 逻辑函数
	* 由逻辑变量组成的表达式的值
		* F = A * B + C
		* F(A,B,C) = A * B + C
* 如何由真值表反推出逻辑函数
* 如何化简逻辑函数
* 卡诺图
	* 有时真值表写成一列比较麻烦
	* 我们可以把真值表写成二维的
	* 卡诺图真正的目的是为了化简更方便
	* 例


# 逻辑电路

* 逻辑电路（logic circuit）由各种逻辑门(logic gate)组成
* 逻辑门之所以称为逻辑门，是因为它们可以实现简单的逻辑运算
* 逻辑门是如何组成的？
	* 继电器
	* 真空管
	* 晶体管
		* 三极管
		* PN结
* 基本的逻辑门有三种
	* 与门(AND Gate)
	* 或门(OR Gate)
	* 非门(NOT Gate)
* 复合逻辑门
	* 异或门(XOR Gate)
	* 与非门(NAND Gate)
		* 其中仅用与非门即可模拟出所有其它的逻辑门
		* https://zh.wikipedia.org/wiki/%E4%B8%8E%E9%9D%9E%E9%97%A8
	* 等等
* 如果我们把相应的逻辑运算表达成逻辑函数，然后构造一个与逻辑函数对应的逻辑电路，则该电路即可表达我们的逻辑
* 由此我们可以使用电路实现任意的逻辑，实际上计算机电路中所有的逻辑门也都是用与非门来表达的
   

# javascript笔记
## 整数在计算机中的表示和运算
  * 整数在计算机中的表达类似于时钟表盘。如对于表盘来说，向前拨动3个刻度的指针，相当于向后拨动9个刻度的指针；反过来，向后拨动5个刻度相当于向前拨动7个刻度，于是减5就可以转换为加7，于是-5用7来表达，二进制中也只是周期不一样，周期为2的n次方，最高位1表示负数，0表示正数；
  * 
  * 原码 1101    12568
    反码 0010    87431 
    补码 0011    87432
    补码=周期-原码
    为了计算方面，通过周期-1-原码+1的方式计算补码（这样做减法不会借位,计算机是通过这样求反码的）
    或者通过（周期-1）-（原码-1）的方式计算补码（结果一样，思路不一样）
  *  位运算符
    - js语言中的整数在参与位运算时用4个字节表示，即32bit
      |按位或     2|3=3   双方化为2进制每bit位进行或运算
      &按位与     2&3=2   双方化为2进制每bit位进行与运算
      ^按位异或 
         - 双方化为2进制每bit位进行异或运算
         - 不同为1.相同为0；
         - 任何数和自身异或都为0，任何数和0异或都为自身； 2^2==0；2^0==2;
      ~按位非   ~2==-3    数字化为2进制每bit位进行非运算
      符号>>按位右移（保留符号位，即左边补1） 15>>3==1;
      符号>>>按位右移（不保留符号位，左边补0） -15>>>3==536870910
      <<按位左移（右边总是补0） 15<<3==120
  *  ** 次方    2**5==32  
     x.toFixed(n)可以让x保留小数点后n位 
##  js编码规范
  * js中回车时解析器会自动加上分号 ，当一行的第一个字符是+，-，/,[,( 这5个字符时，他前面一行必须加分号。
  * 编程语言中不能省略*乘号 ，因为它会把2个变量当做一个新的整体变量  
  * 比较符>= 或者 <=之间不能有空格


## 代码的调试
  * debugger  在代码最前面加一个断点debugger
  * 在sources栏里面鼠标指定断点位置
  
## 高阶函数

   * forEach函数
     array.forEach(function(){}) 方法从头至尾遍历数组，为每个元素调用指定的函数。ES6 的 => 语法可以让匿名函数更简洁，取代 function 关键词。
     只有一个参数，及每个元素的处理函数。
     <!--  var numbers = [1, 2, 3];      
      numbers.forEach(x => console.log(x));
      // 同等于
      numbers.forEach(function (x) {
          console.log(x); -->

   * filter函数
      array.filter(function(){})  filter函数的作用是遍历该集合，然后将该集合中符合某些特定条件的元素组成新的数组，并返回该新数组.
      只有一个参数，及判断所有元素是否符合条件的处理函数。
      <!--  var digits = [1, 4, 5, 10, 15]
      var even = digits.filter(function (number) { return number % 2 == 0 })
      console.log(even))
      // [4, 10] -->

   * map函数
     array.map(function(){})  对数组的每个元素调用定义的回调函数并返回包含结果的数组  
     只有一个参数,及给出映射关系的处理函数
      <!-- var array = [16,25,36];
      array.map(Math.sqrt);
      //array = [4,5,6]

      var array = [11, 22, 33, 44, 55];
      console.log(array.map(function (n) { return n % 10 }))
      //array = [1,2,3,4,5] -->

    * reduce函数
      Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：
      [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
     <!--  var arr = [1, 3, 5, 7, 9];
      arr.reduce(function (x, y) {
      return x + y;
      }); // 25 -->

    * sort函数
      用于数组的排序，返回值大于0交换位置，其它位置不变
      array.sort(function(a,b){return a - b})  从小到大排序
      array.sort(function(a,b){return b - a})  从大到小排序
  
 ## 对象原型
   
  * 基本关系
    构造函数Perser, function  Person(参数){}
    Person的实例person1 ,var person1 = new Person(实参)
    _proto__（隐式原型）与prototype（显式原型），隐式原型指向创建这个对象的函数(constructor)的prototype；
    JavaScript中我们在定义构造函数的时候就会默认有一个prototype的属性。每个对象实例化后其实就是拷贝构造函数中除开prototype属性之外的所有方法和属性，其中会生成一个__proto__属性。
    prototype是站在构造函数的角度讨论原型对象的，用来实现基于原型的继承与属性的共享。__proto__是站在实例对象的角度讨论原型对象，构成原型链，同样用于实现基于原型的继承。

    person1的__prototype__属性等于构造函数Person的prototype属性， person1.__prototype__ == Person.prototype ,都指向了person1的原型；
    person1的原型的原型等于Object的prototype属性，Person.prototype.__prototype__ == Object.prototype.
    person1的原型的原型的原型是Null. Object.prototype.__proto__ == Null

    构造函数Person也是对象,也有__proto__属性,等于它的构造函数Function的prototype属性.Person.__prototype__ == Function.prototype.Function是所有函数的根构造函数.
    构造函数Person的原型也是对象,也有__proto__属性,等于它的构造函数Object的prototype属性Function.prototype.__prototype__ == Object.prototype. Object是所有对象的根构造函数。
    Object里面的的原型对象没有原型了，所以 Object.prototype.__proto__ == Null 


  * Object.create(新创建对象的原型对象)  即为新创建的对象指定一个原型对象
    <!-- var person2 = Object.create(person1);
    person2.__proto__ ；
    // person1 -->

  * constructor 属性  每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。

      原型对象有一个constructor属性，指向该原型对象对应的构造函数
      function Foo(){};

      console.log(Foo.prototype.constructor === Foo);//true

      由于实例对象可以继承原型对象的属性，所以实例对象也拥有constructor属性，同样指向原型对象对应的构造函数
      function Foo(){};
      var f1 = new Foo;
      console.log(f1.constructor === Foo);//true (f1中没有constructor属性，会到f1.__proto__ 中寻找，即f1.__proto__.constructor === Foo)



      ..................................................................................................................................................0
